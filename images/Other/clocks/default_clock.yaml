display:
  - id: !extend main_display
    update_interval: 1s
    pages:
      - id: clock_page
        lambda: |-
          // ---------- Geometry (recompute only on size change) ----------
          const int W = it.get_width();
          const int H = it.get_height();
          static int prevW = -1, prevH = -1;

          static int cx = 0, cy = 0;
          static const int margin = 8;
          static int r_outer = 0, r_sec = 0, r_min = 0, r_hr = 0;

          static int dot_r_sec_small = 2;
          static int dot_r_sec_big   = 3;
          static int dot_r_min       = 5;
          static int dot_r_hr        = 7;

          static int16_t sec_x[60], sec_y[60];
          static int16_t min_x[60], min_y[60];

          if (W != prevW || H != prevH) {
            prevW = W; prevH = H;

            cx = W / 2; cy = H / 2;
            r_outer = (std::min(W, H) / 2) - margin;
            r_sec   = r_outer;
            r_min   = r_outer - 14;
            r_hr    = r_outer - 28;

            // Scale dot sizes with screen size (once per size change)
            dot_r_sec_small = std::max(2, std::min(3, W / 180));
            dot_r_sec_big   = dot_r_sec_small + 1;
            dot_r_min       = dot_r_sec_big + 2;
            dot_r_hr        = dot_r_min + 2;

            // Precompute positions
            const float PI = 3.1415926f;
            for (int i = 0; i < 60; i++) {
              float angle = (i / 60.0f) * 2.0f * PI - PI/2.0f;
              sec_x[i] = cx + (int16_t)(r_sec * cosf(angle));
              sec_y[i] = cy + (int16_t)(r_sec * sinf(angle));
              min_x[i] = cx + (int16_t)(r_min * cosf(angle));
              min_y[i] = cy + (int16_t)(r_min * sinf(angle));
            }
          }

          // ---------- Colors ----------
          static const Color clock_yellow(0xff,0xc1,0x07);
          float rr = id(clock_color_picker).current_values.get_red();
          float gg = id(clock_color_picker).current_values.get_green();
          float bb = id(clock_color_picker).current_values.get_blue();
          if (rr == 0.0f && gg == 0.0f && bb == 0.0f) { rr = gg = bb = 1.0f; } // default white
          const Color clock_col((uint8_t)(rr * 255.0f), (uint8_t)(gg * 255.0f), (uint8_t)(bb * 255.0f));

          static const Color minute_palette[10] = {
            Color(0x3b,0x89,0xe3), Color(0x26,0xed,0x3a), Color(0xff,0xc1,0x07),
            Color(0xff,0x5a,0x36), Color(0xff,0x3b,0x8d), Color(0x9c,0x27,0xb0),
            Color(0x00,0xbc,0xd4), Color(0x8b,0xc3,0x4a), Color(0xfe,0x6d,0x73),
            Color(0x60,0x7d,0x8b)
          };

          // ---------- Time ----------
          auto now = id(sntp_time).now();
          const int sec    = now.second;
          const int minute = now.minute;
          const int hour12 = now.hour % 12;

          // Smooth hour motion anchor (fine even at 1 Hz; future-proof if you speed up)
          static int last_sec = -1;
          static uint32_t sec_anchor_ms = 0;
          if (sec != last_sec) { last_sec = sec; sec_anchor_ms = millis(); }
          float sec_frac = (millis() - sec_anchor_ms) / 1000.0f;
          if (sec_frac < 0.0f) sec_frac = 0.0f;
          if (sec_frac > 0.999f) sec_frac = 0.999f;

          // ---------- Background ----------
          const bool show_wallpaper = id(clock_show_wallpaper).state;
          if (show_wallpaper) {
            // Draw wallpaper each tick so nothing sticks.
            it.image(cx, cy, id(clock_background), ImageAlign::CENTER);
          } else {
            // No wallpaper: clear to black once per tick (cheap and avoids ghosts).
            it.fill(Color::BLACK);
          }

          // ---------- Thin black band under seconds (only needed over wallpaper) ----------
          if (show_wallpaper && id(clock_show_dots).state) {
            int half_thick = dot_r_sec_big + 2;  // enough to cover markers
            for (int dr = -half_thick; dr <= half_thick; dr++) {
              it.circle(cx, cy, r_sec + dr, Color::BLACK);
            }
          }

          // ---------- Seconds ring ----------
          if (id(clock_show_dots).state) {
            // 5-second markers (white)
            for (int i = 0; i < 60; i += 5) {
              it.filled_circle(sec_x[i], sec_y[i], dot_r_sec_big, Color::WHITE);
            }
            // Progress dots (skip 5s positions)
            const Color sec_col = minute_palette[minute % 10];
            for (int i = 0; i <= sec; i++) {
              if (i % 5 == 0) continue;
              it.filled_circle(sec_x[i], sec_y[i], dot_r_sec_small, sec_col);
            }
          }

          // ---------- Minute dot (yellow) ----------
          it.filled_circle(min_x[minute], min_y[minute], dot_r_min, clock_yellow);

          // ---------- Hour dot (yellow, smooth with minute+second) ----------
          {
            const float PI = 3.1415926f;
            float h_pos = (hour12 + (minute + sec_frac) / 60.0f) / 12.0f;
            float h_angle = h_pos * 2.0f * PI - PI/2.0f;
            int hx = cx + (int)(r_hr * cosf(h_angle));
            int hy = cy + (int)(r_hr * sinf(h_angle));
            it.filled_circle(hx, hy, dot_r_hr, clock_yellow);
          }

          // ---------- Time text ----------
          int clock_y = id(clock_show_date).state ? (cy - 24) : cy;
          if (id(clock_24h).state) {
            if (id(clock_show_seconds).state)
              it.strftime(cx, clock_y, id(font_big_clock_mono), clock_col, TextAlign::CENTER, "%H:%M:%S", now);
            else
              it.strftime(cx, clock_y, id(font_big_clock_mono), clock_col, TextAlign::CENTER, "%H:%M", now);
          } else {
            if (id(clock_show_seconds).state)
              it.strftime(cx, clock_y, id(font_big_clock_mono), clock_col, TextAlign::CENTER, "%I:%M:%S%p", now);
            else
              it.strftime(cx, clock_y, id(font_big_clock_mono), clock_col, TextAlign::CENTER, "%I:%M%p", now);
          }

          // ---------- Date ----------
          if (id(clock_show_date).state) {
            if (id(clock_24h).state)
              it.strftime(cx, cy + 14, id(font_big_date), clock_col, TextAlign::CENTER, "%a, %d %b", now);
            else
              it.strftime(cx, cy + 14, id(font_big_date), clock_col, TextAlign::CENTER, "%a, %b %d", now);
          }
